// Estado global da aplicação
const App = {
    DOM: null,
    products: [],
    
    // Função para inicializar o DOM
    initializeDOM() {
        // Primeiro, verificamos se estamos na página de produtos ou na página inicial
        const isProductsPage = document.getElementById('products-container') !== null;
        
        this.DOM = {
            products: {
                container: document.getElementById('products-container'),
                categories: isProductsPage ? document.querySelectorAll('.category') : null,
                grid: document.querySelector('.products-grid')
            },
            modal: {
                container: document.getElementById('product-modal'),
                title: document.getElementById('modal-title'),
                productTitle: document.getElementById('modal-product-title'),
                price: document.getElementById('modal-price'),
                description: document.getElementById('modal-description'),
                mainImage: document.getElementById('modal-main-image'),
                thumbs: document.getElementById('modal-thumbs'),
                buyLink: document.getElementById('modal-buy-link'),
                detailsLink: document.getElementById('modal-details-link'),
                closeButton: document.querySelector('.close-modal'),
                imageContainer: document.querySelector('.modal-main-image')
            },
            nav: {
                container: document.querySelector('nav'),
                mobileMenu: document.querySelector('.mobile-menu')
            },
            hero: {
                backgrounds: document.querySelectorAll('.hero-bg')
            }
        };
        
        return this.DOM;
    },

    // Função para inicializar a aplicação
    async initialize() {
        console.log('Inicializando aplicação...');
        this.initializeDOM();
        
        try {
            // Carregar produtos
            const response = await fetch('./src/db/products.json');
            if (!response.ok) throw new Error('Falha ao carregar produtos');
            this.products = await response.json();
            console.log('Produtos carregados:', this.products);

            // Se estiver na página de produtos, carregar a lista
            if (this.DOM.products.container) {
                this.loadProducts('all');
                this.setupEventListeners();
            }

            // Inicializar outras funcionalidades
            this.initHeroSlideshow();
        } catch (error) {
            console.error('Erro na inicialização:', error);
            if (this.DOM.products.container) {
                this.DOM.products.container.innerHTML = '<p>Não foi possível carregar os produtos.</p>';
            }
        }
    },

    // Configurar event listeners
    setupEventListeners() {
        // Categorias
        if (this.DOM.products.categories) {
            this.DOM.products.categories.forEach(category => {
                category.addEventListener('click', (e) => {
                    console.log('Categoria clicada:', category.dataset.category);
                    this.DOM.products.categories.forEach(c => c.classList.remove('active'));
                    category.classList.add('active');
                    this.loadProducts(category.dataset.category);
                });
            });
        }

        // Menu mobile
        if (this.DOM.nav.mobileMenu) {
            this.DOM.nav.mobileMenu.addEventListener('click', () => {
                this.DOM.nav.container.classList.toggle('active');
            });
        }

        // Modal
        if (this.DOM.modal.closeButton) {
            this.DOM.modal.closeButton.addEventListener('click', () => this.closeModal());
        }

        // Fechar modal ao clicar fora
        window.addEventListener('click', (e) => {
            if (e.target === this.DOM.modal.container) {
                this.closeModal();
            }
        });
    }
};

// Carregar produtos do arquivo JSON
async function fetchProducts() {
    try {
        const res = await fetch('./src/db/products.json');
        if (!res.ok) throw new Error('Falha ao carregar produtos: ' + res.status);
        products = await res.json();
        console.log('Produtos carregados:', products); // Debug
        return products;
    } catch (err) {
        console.error('Erro ao carregar produtos:', err);
        throw err;
    }
}

// Métodos para manipulação de produtos
Object.assign(App, {
    // Carregar produtos na página
    loadProducts(filterCategory = 'all') {
        console.log('Carregando produtos para categoria:', filterCategory);
        
        if (!this.DOM.products.container) {
            console.log('Container de produtos não encontrado');
            return;
        }
        
        // Limpar o container
        this.DOM.products.container.innerHTML = '';
        
        // Filtrar produtos
        const filteredProducts = filterCategory === 'all' 
            ? this.products 
            : this.products.filter(product => product.category === filterCategory);
        
        console.log('Produtos filtrados:', filteredProducts);
        
        // Criar e adicionar cards de produtos
        filteredProducts.forEach((product, index) => {
            const productCard = document.createElement('div');
            productCard.style.animation = `fadeIn 0.5s ease forwards ${index * 0.1}s`;
            productCard.className = 'product-card';
            
            // Criar o HTML do card
            productCard.innerHTML = `
                <div class="product-image">
                    <img src="${product.image}" alt="${product.name}">
                </div>
                <div class="product-info">
                    <h3 class="product-title">${product.name}</h3>
                    <p class="product-description">${product.description.substring(0, 80)}...</p>
                    <div class="product-price">R$ ${product.price.toFixed(2)}</div>
                    <div class="product-actions">
                        <a href="#" class="btn-details" data-id="${product.id}">Ver Detalhes</a>
                        <a href="${product.link}" class="btn-buy" target="_blank">Comprar</a>
                    </div>
                </div>
            `;
            
            // Adicionar o card ao container
            this.DOM.products.container.appendChild(productCard);
            
            // Adicionar evento de detalhes diretamente ao card
            const detailsButton = productCard.querySelector('.btn-details');
            if (detailsButton) {
                detailsButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    const productId = parseInt(detailsButton.dataset.id);
                    this.openModal(productId);
                });
            }
        });
        
        console.log('Produtos carregados com sucesso');
    },
}

// Abrir modal do produto
function openProductModal(productId) {
    const product = products.find(p => p.id === productId);
    if (product) {
        // Resetar o estado do modal
        DOM.modal.container.style.visibility = 'visible';
        DOM.modal.container.classList.remove('closing');
        // Ativar o modal com a animação
        requestAnimationFrame(() => {
            DOM.modal.container.classList.add('active');
        });
        
        DOM.modal.productTitle.textContent = product.name;
        DOM.modal.price.textContent = `R$ ${product.price.toFixed(2)}`;
        DOM.modal.description.textContent = product.description;
        
        // determine images list (prefer product.images)
        const imgs = Array.isArray(product.images) && product.images.length 
            ? product.images 
            : (product.image ? [product.image] : []);

        // set main image
        if (DOM.modal.mainImage) {
            if (imgs.length) {
                DOM.modal.mainImage.src = imgs[0];
                DOM.modal.mainImage.draggable = false;
                DOM.modal.mainImage.alt = product.name;
            } else {
                DOM.modal.mainImage.removeAttribute('src');
                DOM.modal.mainImage.alt = product.name;
            }
        }

        // populate thumbnails
        if (DOM.modal.thumbs) {
            DOM.modal.thumbs.innerHTML = '';
            imgs.forEach((src, idx) => {
                const thumb = document.createElement('img');
                thumb.src = src;
                if (idx === 0) thumb.classList.add('active');
                thumb.addEventListener('click', () => {
                    if (DOM.modal.mainImage) {
                        DOM.modal.mainImage.src = src;
                    }
                    DOM.modal.thumbs.querySelectorAll('img')
                        .forEach(i => i.classList.remove('active'));
                    thumb.classList.add('active');
                });
                DOM.modal.thumbs.appendChild(thumb);
            });
            
            // if there is only one image, hide thumbs container
            DOM.modal.thumbs.style.display = imgs.length <= 1 ? 'none' : '';
        }
        
        DOM.modal.buyLink.href = product.link;
        DOM.modal.detailsLink.href = product.link;
        modal.style.display = 'block';
    }
}

// Fechar modal
function closeProductModal() {
    // reset zoom state if present
    if (DOM.modal.imageContainer && DOM.modal.imageContainer.classList.contains('zoomed')) {
        DOM.modal.imageContainer.classList.remove('zoomed');
        if (DOM.modal.mainImage) {
            DOM.modal.mainImage.style.transform = '';
        }
    }
    
    // Adiciona animação de saída
    DOM.modal.container.classList.add('closing');
    DOM.modal.container.classList.remove('active');
    
    // Remove o modal após a animação terminar
    const handleTransitionEnd = () => {
        DOM.modal.container.classList.remove('closing');
        DOM.modal.container.style.visibility = 'hidden';
        DOM.modal.container.removeEventListener('transitionend', handleTransitionEnd);
    };
    
    DOM.modal.container.addEventListener('transitionend', handleTransitionEnd);
}

// Função para configurar eventos das categorias
function setupCategoryEvents() {
    if (!DOM.products.categories) return;
    
    DOM.products.categories.forEach(categoryElement => {
        categoryElement.addEventListener('click', function() {
            // Remover active de todas as categorias
            DOM.products.categories.forEach(c => c.classList.remove('active'));
            // Adicionar active na categoria clicada
            this.classList.add('active');
            // Carregar produtos da categoria
            const categoryName = this.getAttribute('data-category');
            loadProducts(categoryName);
        });
    });
}

// Função para configurar eventos globais
function setupGlobalEvents() {
    // Menu mobile
    if (DOM.nav && DOM.nav.mobileMenu && DOM.nav.container) {
        DOM.nav.mobileMenu.addEventListener('click', function() {
            DOM.nav.container.classList.toggle('active');
        });
    }

    // Fechar modal ao clicar fora
    if (DOM.modal && DOM.modal.container) {
        window.addEventListener('click', function(e) {
            if (e.target === DOM.modal.container) {
                closeProductModal();
            }
        });
    }
}

// Fechar modal com ESC
// Zoom / pan for modal main image
(function(){
    const container = document.querySelector('.modal-main-image');
    const img = document.getElementById('modal-main-image');
    if (!container || !img) return; // nothing to do if modal not present

    let isZoomed = false;
    const scale = 2; // zoom level
    let tx = 0, ty = 0; // current translate
    let startX = 0, startY = 0; // pointer start
    let startTx = 0, startTy = 0;
    let pointerId = null;
    let moved = false;

    function applyTransform() {
        img.style.transform = `translate(${tx}px, ${ty}px) scale(${isZoomed ? scale : 1})`;
    }

    function clampOffsets(x, y) {
        // use layout sizes (offsetWidth) which are not affected by CSS transforms
        const cW = container.clientWidth;
        const cH = container.clientHeight;
        const iW = img.offsetWidth;
        const iH = img.offsetHeight;
        const scaledW = iW * (isZoomed ? scale : 1);
        const scaledH = iH * (isZoomed ? scale : 1);
        const overflowX = Math.max(0, scaledW - cW);
        const overflowY = Math.max(0, scaledH - cH);
        const minX = -overflowX / 2;
        const maxX = overflowX / 2;
        const minY = -overflowY / 2;
        const maxY = overflowY / 2;
        return [Math.min(maxX, Math.max(minX, x)), Math.min(maxY, Math.max(minY, y))];
    }

    function enableZoom(centerX, centerY) {
        isZoomed = true;
        container.classList.add('zoomed');
        // center on click position: compute relative offsets
        const cRect = container.getBoundingClientRect();
        const iRect = img.getBoundingClientRect();
        // click position relative to image center
        const relX = (centerX - iRect.left) - iRect.width/2;
        const relY = (centerY - iRect.top) - iRect.height/2;
        // scale the relative amounts and clamp
        tx = -relX * (scale - 1);
        ty = -relY * (scale - 1);
        [tx, ty] = clampOffsets(tx, ty);
        applyTransform();
    }

    function disableZoom() {
        isZoomed = false;
        container.classList.remove('zoomed');
        tx = 0; ty = 0;
        img.style.transform = '';
    }

    function onPointerDown(e) {
        // only react when zoomed
        if (!isZoomed) return;
        pointerId = e.pointerId;
        startX = e.clientX; startY = e.clientY;
        startTx = tx; startTy = ty;
        moved = false;
        container.setPointerCapture(pointerId);
    }

    function onPointerMove(e) {
        if (pointerId === null || e.pointerId !== pointerId) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) moved = true;
        tx = startTx + dx; ty = startTy + dy;
        [tx, ty] = clampOffsets(tx, ty);
        applyTransform();
    }

    function onPointerUp(e) {
        if (pointerId === null || e.pointerId !== pointerId) return;
        try { container.releasePointerCapture(pointerId); } catch (err) {}
        pointerId = null;
    }

    // Toggle zoom on click (but not when the user dragged)
    container.addEventListener('pointerdown', function(e){
        // prevent default browser behaviors like image drag or touch scrolling while interacting
        if (e.cancelable) e.preventDefault();
        // start possible drag only when zoomed
        if (isZoomed) onPointerDown(e);
        // track for click toggling
        startX = e.clientX; startY = e.clientY;
        moved = false;
    });

    container.addEventListener('pointermove', function(e){
        if (isZoomed) onPointerMove(e);
        if (Math.abs(e.clientX - startX) > 3 || Math.abs(e.clientY - startY) > 3) moved = true;
    });

    container.addEventListener('pointerup', function(e){
        if (isZoomed) onPointerUp(e);
        // if it was a simple click (no move) toggle zoom
        if (!moved) {
            if (!isZoomed) enableZoom(e.clientX, e.clientY); else disableZoom();
        }
    });

    // also support mouseleave to stop dragging
    container.addEventListener('pointercancel', onPointerUp);
    container.addEventListener('lostpointercapture', onPointerUp);

    // If modal is closed, ensure zoom reset
    const originalClose = closeProductModal;
    // replace closeProductModal with wrapped version
    window.closeProductModal = function(){
        try { disableZoom(); } catch(e){}
        originalClose();
    }

    // handle Escape key to exit zoom first, then close modal
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && modal.style.display === 'block') {
            if (isZoomed) {
                disableZoom();
            } else {
                closeProductModal();
            }
        }
    });

})();

// Close modal when clicking the close button
if (closeModal) closeModal.addEventListener('click', closeProductModal);

// Controle do slideshow do hero
function initHeroSlideshow() {
    if (!DOM.hero.backgrounds || DOM.hero.backgrounds.length === 0) return;
    let currentIndex = 0;

    function showNextSlide() {
        if (!DOM.hero.backgrounds[currentIndex]) return;
        DOM.hero.backgrounds[currentIndex].classList.remove('active');
        currentIndex = (currentIndex + 1) % DOM.hero.backgrounds.length;
        if (DOM.hero.backgrounds[currentIndex]) {
            DOM.hero.backgrounds[currentIndex].classList.add('active');
        }
    }

    // Trocar slide a cada 10 segundos
    setInterval(showNextSlide, 10000);
}

// Inicializar página
document.addEventListener('DOMContentLoaded', async function() {
    console.log('DOM Content Loaded'); // Debug
    
    // Inicializar DOM elements primeiro
    DOM = initializeDOMElements();
    console.log('DOM inicializado:', DOM); // Debug
    
    // Configurar todos os event listeners
    if (DOM.modal && DOM.modal.closeButton) {
        DOM.modal.closeButton.addEventListener('click', closeProductModal);
    }
    
    // Configurar eventos das categorias
    setupCategoryEvents();
    
    // Configurar eventos globais (menu mobile e modal)
    setupGlobalEvents();
    
    // Carregar produtos primeiro
    await fetchProducts();
    
    // Inicializar outras funcionalidades
    initHeroSlideshow();
});
